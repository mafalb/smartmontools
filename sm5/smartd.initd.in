#! @SHELL@

# smartmontools init file for smartd
# Copyright (C) 2002-3 Bruce Allen <smartmontools-support@lists.sourceforge.net>
# $Id: smartd.initd.in,v 1.18 2003/12/30 11:58:45 ballen4705 Exp $
#
# For RedHat and cousins:
# chkconfig: 2345 40 40
# description: Self Monitoring and Reporting Technology (SMART) Daemon
# processname: smartd 
#
# For SuSE and cousins
### BEGIN INIT INFO
# Provides: smartd
# Required-Start: 
# Required-Stop: 
# X-UnitedLinux-Should-Start: 
# Default-Start: 1 2 3 5
# Default-Stop: 0 6
# Description: Start the smartd daemon
### END INIT INFO
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the Free
# Software Foundation; either version 2, or (at your option) any later
# version.
# 
# You should have received a copy of the GNU General Public License (for
# example COPYING); if not, write to the Free Software Foundation, Inc., 675
# Mass Ave, Cambridge, MA 02139, USA.
#
# This code was originally developed as a Senior Thesis by Michael Cornwell
# at the Concurrent Systems Laboratory (now part of the Storage Systems
# Research Center), Jack Baskin School of Engineering, University of
# California, Santa Cruz. http://ssrc.soe.ucsc.edu/.

report_unsupported () {
    echo "Currently the smartmontools package has no init script for"
    echo "the $1 Linux distribution. If you can provide one or this"
    echo "one works after removing some ifdefs, please contact"
    echo "smartmontools-support@lists.sourceforge.net."
    exit 1
}

# Red Hat or Yellow Dog or Mandrake
if [ -f /etc/redhat-release -o -f /etc/yellowdog-release -o -f /etc/mandrake-release ] ; then
    
# Source function library
    . /etc/rc.d/init.d/functions
    
    RETVAL=0
    
    prog=smartd
    
    case "$1" in
	start)
	    echo -n $"Starting $prog: "
	    daemon /usr/sbin/smartd
	    touch /var/lock/subsys/smartd
	    echo
	    ;;
	stop)
	    echo -n $"Shutting down $prog: "
	    killproc smartd
	    rm -f /var/lock/subsys/smartd
	    echo
	    ;;
	reload)
            echo -n $"Reloading $prog daemon configuration: "
	    killproc /usr/sbin/smartd -HUP
	    RETVAL=$?
	    echo
	    ;;
	report)
	    echo -n $"Checking SMART devices now: "
	    killproc /usr/sbin/smartd -USR1
	    RETVAL=$?
	    echo
            ;;
	restart)
	    $0 stop
	    $0 start
	    ;;
	status)
	    status $prog
	    ;;
	*)
	    echo $"Usage: $0 {start|stop|reload|report|restart|status}"
	    RETVAL=1
    esac
    
    exit $RETVAL

# Slackware
elif [ -f /etc/slackware-version ] ; then
    
    case "$1" in
	start)
	    echo -n "Starting smartd: "
	    smartd
	    echo
	    ;;
	stop)
	    echo -n "Shutting down smartd: "
	    killall smartd
	    echo
	    ;;
	restart)
	    $0 stop
	    sleep 1
	    $0 start
	    ;;
	*)
	    echo "Usage: smartd {start|stop|restart}"
	    exit 1
    esac
    
    exit 0
    
# SuSE
elif [ -f /etc/SuSE-release ] ; then
    
    SMARTD_BIN=/usr/sbin/smartd
    test -x $SMARTD_BIN || exit 5
    
   # Shell functions sourced from /etc/rc.status:
   #      rc_check         check and set local and overall rc status
   #      rc_status        check and set local and overall rc status
   #      rc_status -v     ditto but be verbose in local rc status
   #      rc_status -v -r  ditto and clear the local rc status
   #      rc_failed        set local and overall rc status to failed
   #      rc_reset         clear local rc status (overall remains)
   #      rc_exit          exit appropriate to overall rc status
    . /etc/rc.status
    
   # First reset status of this service
    rc_reset
    
   # Return values acc. to LSB for all commands but status:
   # 0 - success
   # 1 - misc error
   # 2 - invalid or excess args
   # 3 - unimplemented feature (e.g. reload)
   # 4 - insufficient privilege
   # 5 - program not installed
   # 6 - program not configured
   #
   # Note that starting an already running service, stopping
   # or restarting a not-running service as well as the restart
   # with force-reload (in case signalling is not supported) are
   # considered a success.
    case "$1" in
	start)
	    echo -n "Starting smartd: "
            ## Start daemon with startproc(8). If this fails
            ## the echo return value is set appropriate.
	    
            # startproc should return 0, even if service is
            # already running to match LSB spec.
            startproc $SMARTD_BIN
	    
            # Remember status and be verbose
            rc_status -v
	    ;;
	stop)
	    echo -n "Shutting down smartd: "
            killproc -QUIT $SMARTD_BIN
	    
            # Remember status and be verbose
            rc_status -v
	    ;;
	restart)
	    $0 stop
	    sleep 1
	    $0 start
	    ;;
        status)
            echo -n "Checking for service smartd: "
            ## Check status with checkproc(8), if process is running
            ## checkproc will return with exit status 0.
	    
            # Status has a slightly different for the status command:
            # 0 - service running
            # 1 - service dead, but /var/run/  pid  file exists
            # 2 - service dead, but /var/lock/ lock file exists
            # 3 - service not running
	    
            # NOTE: checkproc returns LSB compliant status values.
            checkproc $SMARTD_BIN
            rc_status -v
            ;;
	*)
	    echo "Usage: smartd {start|stop|restart|status}"
	    exit 1
    esac
    
    rc_exit
    
# Add other linux distributions HERE, using elif...
elif [ -f /etc/environment.corel ] ; then
    report_unsupported "Corel"
elif [ -f /etc/debian_version ] ; then
        PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin
	SMARTCTL=/usr/sbin/smartctl
	SMARTD=/usr/sbin/smartd
	SMARTDPID=/var/run/smartd.pid
	[ -x $SMARTCTL ] || exit 0
	[ -x $SMARTD ] || exit 0
	RET=0

	[ -r /etc/default/smartmontools ] && . /etc/default/smartmontools

	smartd_opts="--pidfile $SMARTDPID $smartd_opts"
	
	case "$1" in
	start)
		echo -n "Starting S.M.A.R.T. daemon: smartd"
		if start-stop-daemon --start --quiet --pidfile $SMARTDPID \
	    	--exec $SMARTD -- $smartd_opts; then 
	    		echo "."
		else
	        	echo " (failed)"
			RET=1
	    	fi
	;;
	stop)
		echo -n "Stopping S.M.A.R.T. daemon: smartd"
		start-stop-daemon --stop --quiet --oknodo --pidfile $SMARTDPID
		echo "."
	;;
	restart|force-reload)
       		$0 stop
        	$0 start
        	;;
  	*)
		echo "Usage: /etc/init.d/smartmontools {start|stop|restart|force-reload}"
		exit 1
	esac
 	exit $RET
elif [ -f /etc/gentoo-release ] ; then
    report_unsupported "Gentoo"
elif [ -f /etc/turbolinux-release ] ; then
    report_unsupported "Turbolinux"
elif uname -a | grep FreeBSD > /dev/null 2>&1 ; then

    PID_FILE=/var/run/smartd.pid
    
    case "$1" in
	start)
	    smartd -p $PID_FILE
	    echo -n "smartd "
	    ;;
	stop)
	    kill `cat $PID_FILE`
	    echo -n "smartd "
	    ;;
	restart)
	    $0 stop
	    sleep 1
	    $0 start
	    ;;
	*)
	    echo "Usage: smartd {start|stop|restart}"
	    exit 1
    esac
    
    exit 0
elif uname -a | grep SunOS > /dev/null 2>&1 ; then
    
    PID_FILE=/var/run/smartd.pid
    
    case "$1" in
	start)
	    smartd -p $PID_FILE
	    echo -n "smartd "
	    ;;
	stop)
	    [ -f $PID_FILE ] && kill `cat $PID_FILE`
	    echo -n "smartd "
	    ;;
	restart)
	    $0 stop
	    sleep 1
	    $0 start
	    ;;
	*)
	    echo "Usage: smartd {start|stop|restart}"
	    exit 1
    esac
    
    exit 0
else
    report_unsupported "Unknown"
fi

# One should NEVER arrive here, except for a badly written case above,
# that fails to exit.  
echo "SOMETHING IS WRONG WITH THE SMARTD STARTUP SCRIPT"
exit 1
